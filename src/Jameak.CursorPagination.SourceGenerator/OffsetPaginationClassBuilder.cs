using Jameak.CursorPagination.Abstractions;
using Jameak.CursorPagination.Abstractions.Enums;
using Jameak.CursorPagination.Abstractions.Internal;
using Jameak.CursorPagination.Abstractions.OffsetPagination;
using Jameak.CursorPagination.SourceGenerator.Poco;
using static Jameak.CursorPagination.SourceGenerator.HelperMethods;

namespace Jameak.CursorPagination.SourceGenerator;
internal static class OffsetPaginationClassBuilder
{
    private const string PrivateHelperClassName = "PrivateHelper";

    private const string NamespacePlaceholder = "{NAMESPACE}";
    private const string ClassVisibilityPlaceholder = "{CLASS_VISIBILITY}";
    private const string GeneratorClassNamePlaceholder = "{CLASS_NAME}";
    private const string TargetClassTypePlaceholder = "{TARGET_CLASS_TYPE}";
    private const string ApplyOrderByMethodBodyPlaceholder = "{APPLY_ORDER_BY_METHOD}";

    private static readonly string s_keySetGeneratorTemplate = $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the {{s_generatorAssemblyName.Name}} source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

{{NamespacePlaceholder}}

{{ClassVisibilityPlaceholder}} partial class {{GeneratorClassNamePlaceholder}} : global::{{typeof(IOffsetPaginationStrategy<>).GetFullNameWithoutGenericArity()}}<{{TargetClassTypePlaceholder}}>
{
    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>
        {{nameof(IOffsetPaginationStrategy<object>.ApplyPagination)}}(
        global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}> queryable,
        int pageSize,
        bool checkHasNextPage,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection,
        global::{{typeof(OffsetCursor).FullName}}? cursor)
    {
        if (queryable == null)
        {
            throw new global::System.ArgumentNullException(nameof(queryable));
        }

        var funcs = {{nameof(IOffsetPaginationStrategy<object>.BuildPaginationMethods)}}(pageSize, checkHasNextPage, paginationDirection, cursor);
        var ordered = funcs.applyOrderExpr(queryable);
        var skipped = funcs.applySkip(ordered);
        var limited = funcs.applyTake(skipped);
        return limited;
    }

    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public (global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IOrderedQueryable<{{TargetClassTypePlaceholder}}>> applyOrderExpr,
            global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>> applySkip,
            global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>> applyTake)
        {{nameof(IOffsetPaginationStrategy<object>.BuildPaginationMethods)}}(
        int pageSize,
        bool checkHasNextPage,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection,
        global::{{typeof(OffsetCursor).FullName}}? cursor)
    {
        global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IOrderedQueryable<{{TargetClassTypePlaceholder}}>> orderFunc =
            queryable => {{PrivateHelperClassName}}.ApplyOrderBy(queryable, paginationDirection);
        
        return {{typeof(InternalProcessingHelper).FullName}}.{{nameof(InternalProcessingHelper.OffsetBuildPaginationMethods)}}(
            pageSize,
            checkHasNextPage,
            orderFunc,
            cursor);
    }

    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public global::System.Collections.Generic.IEnumerable<global::{{typeof(RowData<,>).GetFullNameWithoutGenericArity()}}<{{TargetClassTypePlaceholder}}, global::{{typeof(OffsetCursor).FullName}}>>
        {{nameof(IOffsetPaginationStrategy<object>.PostProcessMaterializedResult)}}(
        global::System.Collections.Generic.List<{{TargetClassTypePlaceholder}}> materializedResult,
        int pageSize,
        bool checkHasNextPage,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection,
        global::{{typeof(OffsetCursor).FullName}}? cursor,
        out bool? hasNextPage)
    {
        return {{typeof(InternalProcessingHelper).FullName}}.{{nameof(InternalProcessingHelper.OffsetPostProcessResult)}}(
            materializedResult,
            pageSize,
            checkHasNextPage,
            paginationDirection,
            cursor,
            out hasNextPage);
    }
}

{{GeneratedCodeAttribute}}
file class {{PrivateHelperClassName}}
{
    internal static int ComputeToTake(int pageSize)
    {
        checked
        {
            return pageSize + 1;
        }
    }

    internal static global::System.Linq.IOrderedQueryable<{{TargetClassTypePlaceholder}}> ApplyOrderBy(
        global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}> queryable,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection)
    {
{{ApplyOrderByMethodBodyPlaceholder}}
    }
}

""";

    public static (string fileContent, List<CacheableDiagnosticInfo> errors) GenerateClass(ExtractedOffsetData data)
    {
        var errors = new List<CacheableDiagnosticInfo>();

        var orderByMethodBody = CreateApplyOrderByMethodBody(data.PropertyConfigurations, 2);

        var classString = s_keySetGeneratorTemplate
            .Replace(NamespacePlaceholder, data.Namespace == null ? "" : $"namespace {data.Namespace};")
            .Replace(TargetClassTypePlaceholder, data.PaginationTargetTypeFullname)
            .Replace(GeneratorClassNamePlaceholder, data.Name)
            .Replace(ClassVisibilityPlaceholder, data.Visibility)
            .Replace(ApplyOrderByMethodBodyPlaceholder, orderByMethodBody);

        return (classString.Replace("\r\n", "\n"), errors);
    }
}
