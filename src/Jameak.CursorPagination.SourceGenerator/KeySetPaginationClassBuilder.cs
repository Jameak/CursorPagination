using System.Globalization;
using System.Text;
using Jameak.CursorPagination.Abstractions.Enums;
using Jameak.CursorPagination.Abstractions.Exceptions;
using Jameak.CursorPagination.Abstractions.Internal;
using Jameak.CursorPagination.Abstractions.KeySetPagination;
using Jameak.CursorPagination.SourceGenerator.Helpers;
using Jameak.CursorPagination.SourceGenerator.Poco;
using static Jameak.CursorPagination.SourceGenerator.HelperMethods;

namespace Jameak.CursorPagination.SourceGenerator;
internal static class KeySetPaginationClassBuilder
{
    private const string PrivateHelperClassName = "PrivateHelper";
    private const string GeneratedCursorClassName = "Cursor";

    private const string NamespacePlaceholder = "{NAMESPACE}";
    private const string ClassVisibilityPlaceholder = "{CLASS_VISIBILITY}";
    private const string GeneratorClassNamePlaceholder = "{CLASS_NAME}";
    private const string TargetClassTypePlaceholder = "{TARGET_CLASS_TYPE}";
    private const string TargetClassTypeXmlDocPlaceholder = "{TARGET_CLASS_TYPE_XMLDOC}";
    private const string ApplyOrderByMethodBodyPlaceholder = "{APPLY_ORDER_BY_METHOD}";
    private const string GetWhereExprMethodBodyPlaceholder = "{GET_WHERE_EXPR_METHOD_BODY}";
    private const string CursorCallConstructorPlaceholder = "{CURSOR_CONSTRUCTOR_CALL_ARGUMENTS}";
    private const string CursorConstructorPlaceholder = "{CURSOR_CLASS_CONSTRUCTOR}";
    private const string CursorPropertiesPlaceholder = "{CURSOR_PROPERTIES}";
    private const string TokenSerializerFragmentPlaceholder = "{TOKEN_SERIALIZER_FRAGMENT}";
    private const string TokenSerializerInterfacePlaceholder = "{TOKEN_SERIALIZER_INTERFACE}";
    private const string TokenSerializerPrivateHelperFragmentPlaceholder = "{TOKEN_SERIALIZER_PRIVATEHELPER_FRAGMENT}";
    private const string AdditionalFileLocalClassesPlaceholder = "{ADDITIONAL_FILE_LOCAL_CLASSES}";
    private const string JsonAdditionalConvertersPlaceholder = "{JSON_ADDITIONAL_CONVERTERS}";
    private const string JsonNamingPolicyPropertySwitchCasePlaceholder = "{JSON_NAMING_POLICY_SWITCH_CASE}";

    private static readonly string s_dateTimeJsonRoundtripConverterClass = $$"""
file class DateTimeRoundtripJsonConverter : global::System.Text.Json.Serialization.JsonConverter<global::System.DateTime>
{
    public override global::System.DateTime Read(ref global::System.Text.Json.Utf8JsonReader reader, global::System.Type typeToConvert, global::System.Text.Json.JsonSerializerOptions options)
    {
        var stringValue = reader.GetString() ?? throw new global::{{typeof(DateTimeRoundtripJsonException).FullName}}("Cannot deserialize 'null' json value into DateTime object.");
        var split = stringValue.Split(':');

        if (split.Length != 2)
        {
            throw new global::{{typeof(DateTimeRoundtripJsonException).FullName}}("String to convert into DateTime is invalid.");
        }

        try
        {
            return new global::System.DateTime(long.Parse(split[0], global::System.Globalization.CultureInfo.InvariantCulture), split[1] switch
            {
                "L" => global::System.DateTimeKind.Local,
                "UTC" => global::System.DateTimeKind.Utc,
                "Un" => global::System.DateTimeKind.Unspecified,
                _ => throw new global::System.NotSupportedException($"Unhandled serialized kind: {split[1]}"),
            });
        }
        catch (global::System.Exception ex)
        {
            throw new global::{{typeof(DateTimeRoundtripJsonException).FullName}}("String to convert into DateTime is invalid.", ex);
        }
    }

    public override void Write(global::System.Text.Json.Utf8JsonWriter writer, global::System.DateTime value, global::System.Text.Json.JsonSerializerOptions options)
    {
        var stringValue = value.Ticks + ":" + value.Kind switch
        {
            global::System.DateTimeKind.Local => "L",
            global::System.DateTimeKind.Utc => "UTC",
            global::System.DateTimeKind.Unspecified => "Un",
            _ => throw new global::System.NotSupportedException($"Unhandled kind: {value.Kind}"),
        };

        writer.WriteStringValue(stringValue);
    }
}
""";

    private static readonly string s_jsonNamingPolicyClass = $$"""
file class CursorHiddenNamePolicy : global::System.Text.Json.JsonNamingPolicy
{
    public override string ConvertName(string name)
    {
        return name switch
        {
{{JsonNamingPolicyPropertySwitchCasePlaceholder}}
            _ => throw new global::System.NotImplementedException($"Unhandled name: {name}"),
        };
    }
}
""";

    private static readonly string s_keySetGeneratorTemplate = $$"""
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the {{s_generatorAssemblyName.Name}} source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

{{NamespacePlaceholder}}

{{ClassVisibilityPlaceholder}} partial class {{GeneratorClassNamePlaceholder}} : global::{{typeof(IKeySetPaginationStrategy<,>).GetFullNameWithoutGenericArity()}}<{{TargetClassTypePlaceholder}}, {{GeneratorClassNamePlaceholder}}.{{GeneratedCursorClassName}}>{{TokenSerializerInterfacePlaceholder}}
{
    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>
        {{nameof(IKeySetPaginationStrategy<object, IKeySetCursor>.ApplyPagination)}}(
        global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}> queryable,
        int pageSize,
        bool checkHasNextPage,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection,
        {{GeneratedCursorClassName}}? afterCursor)
    {
        if (queryable == null)
        {
            throw new global::System.ArgumentNullException(nameof(queryable));
        }
        
        var funcs = {{nameof(IKeySetPaginationStrategy<object, IKeySetCursor>.BuildPaginationMethods)}}(pageSize, checkHasNextPage, paginationDirection, afterCursor);
        var filtered = funcs.applyWhereExpr(queryable);
        var ordered = funcs.applyOrderExpr(filtered);
        var limited = funcs.applyTake(ordered);
        return limited;
    }

    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public (global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>> applyWhereExpr,
            global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IOrderedQueryable<{{TargetClassTypePlaceholder}}>> applyOrderExpr,
            global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>> applyTake)
        {{nameof(IKeySetPaginationStrategy<object, IKeySetCursor>.BuildPaginationMethods)}}(
        int pageSize,
        bool checkHasNextPage,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection,
        {{GeneratedCursorClassName}}? afterCursor)
    {
        global::{{typeof(InternalProcessingHelper).FullName}}.{{nameof(InternalProcessingHelper.ThrowIfPageSizeInvalid)}}(pageSize, checkHasNextPage);

        var whereExpr = {{PrivateHelperClassName}}.GetWhereExpr(afterCursor, paginationDirection);
        global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>> whereFunc;
        if(whereExpr != null)
        {
            whereFunc = queryable => global::System.Linq.Queryable.Where(queryable, whereExpr);
        }
        else
        {
            whereFunc = queryable => queryable;
        }

        global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IOrderedQueryable<{{TargetClassTypePlaceholder}}>> orderFunc =
            queryable => {{PrivateHelperClassName}}.ApplyOrderBy(queryable, paginationDirection);

        var toTake = pageSize;
        if(checkHasNextPage)
        {
            toTake = {{PrivateHelperClassName}}.ComputeToTake(pageSize);
        }

        global::System.Func<global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>, global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}>> takeFunc =
            queryable => global::System.Linq.Queryable.Take(queryable, toTake);

        return (whereFunc, orderFunc, takeFunc);
    }

    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public void {{nameof(IKeySetPaginationStrategy<object, IKeySetCursor>.PostProcessMaterializedResultInPlace)}}(
        global::System.Collections.Generic.List<{{TargetClassTypePlaceholder}}> materializedResult,
        int pageSize,
        bool checkHasNextPage,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection,
        out bool? hasNextPage)
    {
        {{typeof(InternalProcessingHelper).FullName}}.{{nameof(InternalProcessingHelper.KeySetPostProcessResultInPlace)}}(
            materializedResult,
            pageSize,
            checkHasNextPage,
            paginationDirection,
            out hasNextPage);
    }

    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public {{GeneratedCursorClassName}} {{nameof(IKeySetPaginationStrategy<object, IKeySetCursor>.CreateCursor)}}({{TargetClassTypePlaceholder}} data)
    {
        if (data == null)
        {
            throw new global::System.ArgumentNullException(nameof(data));
        }

        return new {{GeneratedCursorClassName}}({{CursorCallConstructorPlaceholder}});
    }

{{TokenSerializerFragmentPlaceholder}}
    /// <summary>
    /// Source generated {{GeneratedCursorClassName}} holding the data necessary to paginate the
    /// {{TargetClassTypeXmlDocPlaceholder}}
    /// type using the fields matching this strategy.
    /// </summary>
    {{GeneratedCodeAttribute}}
    public sealed record {{GeneratedCursorClassName}} : global::{{typeof(IKeySetCursor).FullName}}
    {
{{CursorPropertiesPlaceholder}}

{{CursorConstructorPlaceholder}}
    }
}

{{GeneratedCodeAttribute}}
file class {{PrivateHelperClassName}}
{
    internal const char CursorElemSeparator = ';';

    internal static int ComputeToTake(int pageSize)
    {
        checked
        {
            return pageSize + 1;
        }
    }

    internal static global::System.Linq.IOrderedQueryable<{{TargetClassTypePlaceholder}}> ApplyOrderBy(
        global::System.Linq.IQueryable<{{TargetClassTypePlaceholder}}> queryable,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection)
    {
{{ApplyOrderByMethodBodyPlaceholder}}
    }

    internal static global::System.Linq.Expressions.Expression<global::System.Func<{{TargetClassTypePlaceholder}}, bool>>? GetWhereExpr(
        {{GeneratorClassNamePlaceholder}}.{{GeneratedCursorClassName}}? cursor,
        global::{{typeof(PaginationDirection).FullName}} paginationDirection)
    {
{{GetWhereExprMethodBodyPlaceholder}}
    }
{{TokenSerializerPrivateHelperFragmentPlaceholder}}}{{AdditionalFileLocalClassesPlaceholder}}

""";

    private static readonly string s_cursorSerializerFragmentTemplate = $$"""
#region IKeySetCursorSerializer implementation
    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public {{GeneratedCursorClassName}} {{nameof(IKeySetCursorSerializer<IKeySetCursor>.CursorFromString)}}(string cursorString)
    {
        if (cursorString == null)
        {
            throw new global::System.ArgumentNullException(nameof(cursorString));
        }

        try
        {
            var decodedString = global::{{typeof(InternalProcessingHelper).FullName}}.{{nameof(InternalProcessingHelper.UrlSafeBase64Decode)}}(cursorString);
            return global::System.Text.Json.JsonSerializer.Deserialize<{{GeneratedCursorClassName}}>(decodedString, options: {{PrivateHelperClassName}}.JsonOptions)
              ?? throw new global::{{typeof(KeySetCursorDeserializationException).FullName}}($"Deserializing '{nameof(cursorString)}' argument produced null {{GeneratedCursorClassName}} object.");
        }
        catch (global::System.Exception ex)
        {
            throw new global::{{typeof(KeySetCursorDeserializationException).FullName}}($"Failed to decode or deserialize '{nameof(cursorString)}' argument value.", ex);
        }
    }

    /// <inheritdoc />
    {{GeneratedCodeAttribute}}
    public string {{nameof(IKeySetCursorSerializer<IKeySetCursor>.CursorToString)}}({{GeneratedCursorClassName}} cursor)
    {
        if (cursor == null)
        {
            throw new global::System.ArgumentNullException(nameof(cursor));
        }

        try
        {
            var jsonString = global::System.Text.Json.JsonSerializer.Serialize(cursor, options: {{PrivateHelperClassName}}.JsonOptions);
            return global::{{typeof(InternalProcessingHelper).FullName}}.{{nameof(InternalProcessingHelper.UrlSafeBase64Encode)}}(jsonString);
        }
        catch (global::System.Exception ex)
        {
            throw new global::{{typeof(KeySetCursorDeserializationException).FullName}}($"Failed to serialize '{nameof(cursor)}' argument value.", ex);
        }
    }
#endregion

""";

    private static readonly string s_cursorSerializerPrivateHelperFragmentTemplate = $$"""
#region IKeySetCursorSerializer De-/serialization methods
    internal static global::System.Text.Json.JsonSerializerOptions JsonOptions { get; } = InitializeJsonOptions();

    private static global::System.Text.Json.JsonSerializerOptions InitializeJsonOptions()
    {
        var options = new global::System.Text.Json.JsonSerializerOptions
        {
            NumberHandling = System.Text.Json.Serialization.JsonNumberHandling.AllowNamedFloatingPointLiterals,
            PropertyNamingPolicy = new CursorHiddenNamePolicy(),
        };
        {{JsonAdditionalConvertersPlaceholder}}
        return options;
    }
#endregion

""";

    private static string CreateCursorConstructor(EquatableArray<PropertyConfiguration> properties)
    {
        return $$"""
            {{Indent(2)}}public {{GeneratedCursorClassName}}({{string.Join(", ", properties.Select(prop => prop.PropertyTypeFullName + " " + prop.PropertyNameForCursorField))}})
            {{Indent(2)}}{
            {{string.Join("\n", properties.Select(GeneratePropertyAssignment))}}
            {{Indent(2)}}}
            """;

        static string GeneratePropertyAssignment(PropertyConfiguration prop)
        {
            var sb = new StringBuilder();
            if (prop.IsNullableValueType && prop.NullCoalesceRhs == null)
            {
                sb.AppendLine($$"""
                                     {{Indent(3)}}if ({{prop.PropertyNameForCursorField}} == null)
                                     {{Indent(3)}}{
                                     {{Indent(3)}}    throw new global::{{typeof(KeySetCursorNullValueException).FullName}}(nameof({{prop.PropertyNameForCursorField}}));
                                     {{Indent(3)}}}
                                     """);
                sb.AppendLine();
            }

            sb.Append($"{Indent(3)}this.{prop.PropertyNameForCursorField} = {prop.PropertyNameForCursorField};");
            return sb.ToString();
        }
    }

    private static string CreateGetWhereExprMethodBody(ExtractedKeySetData data)
    {
        return $$"""
            {{Indent(2)}}if(cursor == null)
            {{Indent(2)}}{
            {{Indent(2)}}    return null;
            {{Indent(2)}}}

            {{string.Join("\n", data.PropertyConfigurations.Select(prop => $"{Indent(2)}var {prop.PropertyNameForCursorField}Value = cursor.{prop.PropertyNameForCursorField};"))}}

            {{Indent(2)}}switch (paginationDirection)
            {{Indent(2)}}{
            {{Indent(2)}}    case global::{{typeof(PaginationDirection).FullName}}.{{nameof(PaginationDirection.Forward)}}:
            {{Indent(2)}}        return obj =>
            {{CreateKeySetPaginationExprBody(data.PropertyConfigurations, PaginationDirection.Forward)}};
            {{Indent(2)}}    case global::{{typeof(PaginationDirection).FullName}}.{{nameof(PaginationDirection.Backward)}}:
            {{Indent(2)}}        return obj =>
            {{CreateKeySetPaginationExprBody(data.PropertyConfigurations, PaginationDirection.Backward)}};
            {{Indent(2)}}    default:
            {{Indent(2)}}        throw new global::System.ArgumentException("Invalid pagination direction specified.", nameof(paginationDirection));
            {{Indent(2)}}}
            """;

        static string CreateKeySetPaginationExprBody(EquatableArray<PropertyConfiguration> properties, PaginationDirection paginationDirection)
        {
            if (properties.Length == 1)
            {
                var property = properties.Single();
                return Indent(5) + CreateComparisonString(property, GetComparisonOperator(property, orEqual: false, paginationDirection));
            }

            // Optimization note: This first clause is redundant but the database optimizer can use it as an access predicate.
            // For more details, see https://use-the-index-luke.com/sql/partial-results/fetch-next-page#sb-equivalent-logic
            return $"""
                {Indent(5)}{CreateComparisonString(properties[0], GetComparisonOperator(properties[0], orEqual: true, paginationDirection))}
                {Indent(5)}&& (
                {CreateMultiColumnKeySetPattern(properties, paginationDirection)}
                {Indent(5)})
                """;
        }

        static string CreateMultiColumnKeySetPattern(EquatableArray<PropertyConfiguration> properties, PaginationDirection paginationDirection)
        {
            // Composite key-set pagination with multiple columns, all in ascending direction, using forward pagination, looks like this in SQL:
            //   (x > a) OR
            //   (x = a AND y > b) OR
            //   (x = a AND y = b AND z > c) OR [etc.]
            var innerLimit = 1;
            var outerLoopResult = new List<string>();
            for (int i = 0; i < properties.Length; i++)
            {
                var innerLoopResult = new List<string>();
                for (int j = 0; j < innerLimit; j++)
                {
                    var isLastInner = j + 1 == innerLimit;
                    innerLoopResult.Add(isLastInner
                        ? CreateComparisonString(properties[j], GetComparisonOperator(properties[j], orEqual: false, paginationDirection))
                        : CreateComparisonString(properties[j], "=="));
                }

                outerLoopResult.Add("(" + string.Join(" && ", innerLoopResult) + ")");
                innerLimit++;
            }

            return string.Join(" ||\n", outerLoopResult.Select(line => Indent(6) + line));
        }

        static string GetComparisonOperator(PropertyConfiguration property, bool orEqual, PaginationDirection direction)
        {
            // When paginating backwards, we need to invert all our signs.
            bool isGreaterThan = direction switch
            {
                PaginationDirection.Forward when property.Direction == PaginationOrdering.Ascending => true,
                PaginationDirection.Forward when property.Direction == PaginationOrdering.Descending => false,
                PaginationDirection.Backward when property.Direction == PaginationOrdering.Ascending => false,
                PaginationDirection.Backward when property.Direction == PaginationOrdering.Descending => true,
                _ => throw new ArgumentOutOfRangeException(nameof(direction), $"Unhandled direction value: direction={direction} & property.Direction={property.Direction}"),
            };

            return orEqual
                ? (isGreaterThan ? ">=" : "<=")
                : (isGreaterThan ? ">" : "<");
        }

        static string CreateComparisonString(PropertyConfiguration property, string operation)
        {
            var propertyValues = GetPropertyValue(property);
            return TypeIsCompareToSpecialCase(property.PropertyTypeFullName)
                ? $"{propertyValues.dbField}.CompareTo({propertyValues.cursorField}) {operation} 0"
                : $"{propertyValues.dbField} {operation} {propertyValues.cursorField}";
        }

        static (string dbField, string cursorField) GetPropertyValue(PropertyConfiguration property)
        {
            if (property.NullCoalesceRhs != null)
            {
                return ($"(obj.{property.PropertyAccessor} ?? {property.NullCoalesceRhs})", $"({property.PropertyNameForCursorField}Value ?? {property.NullCoalesceRhs})");
            }

            if (property.IsNullableValueType)
            {
                return ($"obj.{property.PropertyAccessor}!.Value", $"{property.PropertyNameForCursorField}Value!.Value");
            }

            return ($"obj.{property.PropertyAccessor}!", $"{property.PropertyNameForCursorField}Value!");
        }
    }

    public static (string fileContent, List<CacheableDiagnosticInfo> errors) GenerateClass(ExtractedKeySetData data)
    {
        var errors = new List<CacheableDiagnosticInfo>();

        var orderByMethodBody = CreateApplyOrderByMethodBody(data.PropertyConfigurations, 2);
        var cursorConstructorcallArguments = string.Join(", ", data.PropertyConfigurations.Select(prop => "data." + prop.PropertyAccessor));
        var cursorProperties = string.Join("\n", data.PropertyConfigurations.Select(prop => $"{Indent(2)}public {prop.PropertyTypeFullName} {prop.PropertyNameForCursorField} {{ get; init; }}"));

        var jsonSerialiationIsEnabledAndDateTimePropertyExists = data.GenerateKeySetCursorSerialization == KeySetCursorSerializerGeneration.UseSystemTextJson && data.PropertyConfigurations.Any(e => e.PropertyTypeFullName == "global::System.DateTime");
        var additionalFileLocalClasses = "";
        if (data.GenerateKeySetCursorSerialization == KeySetCursorSerializerGeneration.UseSystemTextJson)
        {
            additionalFileLocalClasses = "\n\n" + s_jsonNamingPolicyClass;
            if (jsonSerialiationIsEnabledAndDateTimePropertyExists)
            {
                additionalFileLocalClasses += "\n\n" + s_dateTimeJsonRoundtripConverterClass;
            }
        }

        var classString = s_keySetGeneratorTemplate
            .Replace(TokenSerializerFragmentPlaceholder, data.GenerateKeySetCursorSerialization == KeySetCursorSerializerGeneration.UseSystemTextJson ? s_cursorSerializerFragmentTemplate : "")
            .Replace(TokenSerializerPrivateHelperFragmentPlaceholder, data.GenerateKeySetCursorSerialization == KeySetCursorSerializerGeneration.UseSystemTextJson ? s_cursorSerializerPrivateHelperFragmentTemplate : "")
            .Replace(AdditionalFileLocalClassesPlaceholder, additionalFileLocalClasses)
            .Replace(JsonAdditionalConvertersPlaceholder, jsonSerialiationIsEnabledAndDateTimePropertyExists ? $"\n{Indent(2)}options.Converters.Add(new DateTimeRoundtripJsonConverter());\n" : "")
            .Replace(TokenSerializerInterfacePlaceholder, data.GenerateKeySetCursorSerialization == KeySetCursorSerializerGeneration.UseSystemTextJson ? $", global::{typeof(IKeySetCursorSerializer<>).GetFullNameWithoutGenericArity()}<{GeneratorClassNamePlaceholder}.{GeneratedCursorClassName}>" : "")
            .Replace(NamespacePlaceholder, data.Namespace == null ? "" : $"namespace {data.Namespace};")
            .Replace(TargetClassTypePlaceholder, data.PaginationTargetTypeFullname)
            .Replace(GeneratorClassNamePlaceholder, data.Name)
            .Replace(ClassVisibilityPlaceholder, data.Visibility)
            .Replace(ApplyOrderByMethodBodyPlaceholder, orderByMethodBody)
            .Replace(GetWhereExprMethodBodyPlaceholder, CreateGetWhereExprMethodBody(data))
            .Replace(CursorCallConstructorPlaceholder, cursorConstructorcallArguments)
            .Replace(CursorPropertiesPlaceholder, cursorProperties)
            .Replace(CursorConstructorPlaceholder, CreateCursorConstructor(data.PropertyConfigurations))
            .Replace(JsonNamingPolicyPropertySwitchCasePlaceholder, CreateJsonNamingPolicySwitchCases(data.Name, data.PropertyConfigurations))
            .Replace(TargetClassTypeXmlDocPlaceholder, GetXmlDocTypeName(data.PaginationTargetTypeFullname));

        return (classString.Replace("\r\n", "\n"), errors);

        static string GetXmlDocTypeName(string typeFullName)
        {
            return TrimGlobalAlias(typeFullName).Replace("<", "&lt;").Replace(">", "&gt;");
        }
    }

    private static string CreateJsonNamingPolicySwitchCases(string strategyClassName, EquatableArray<PropertyConfiguration> propertyConfigurations)
    {
        return string.Join(",\n", propertyConfigurations
            .Select((prop, index) => $"{Indent(3)}nameof({strategyClassName}.{GeneratedCursorClassName}.{prop.PropertyNameForCursorField}) => \"{index.ToString(CultureInfo.InvariantCulture)}\"")) + ",";
    }
}
