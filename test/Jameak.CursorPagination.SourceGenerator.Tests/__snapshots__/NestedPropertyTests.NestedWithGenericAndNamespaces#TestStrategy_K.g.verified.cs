//HintName: TestStrategy_K.g.cs
//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by the Jameak.CursorPagination.SourceGenerator source generator
//
//     Changes to this file may cause incorrect behavior and will be lost if the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

#nullable enable

namespace OtherNamespace;

internal partial class TestStrategy : global::Jameak.CursorPagination.Abstractions.KeySetPagination.IKeySetPaginationStrategy<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>, TestStrategy.Cursor>, global::Jameak.CursorPagination.Abstractions.KeySetPagination.IKeySetCursorSerializer<TestStrategy.Cursor>
{
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Jameak.CursorPagination.SourceGenerator", "LOCALBUILD")]
    public global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>
        ApplyPagination(
        global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>> queryable,
        int pageSize,
        bool checkHasNextPage,
        global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection paginationDirection,
        Cursor? afterCursor)
    {
        if (queryable == null)
        {
            throw new global::System.ArgumentNullException(nameof(queryable));
        }
        
        var funcs = BuildPaginationMethods(pageSize, checkHasNextPage, paginationDirection, afterCursor);
        var filtered = funcs.applyWhereExpr(queryable);
        var ordered = funcs.applyOrderExpr(filtered);
        var limited = funcs.applyTake(ordered);
        return limited;
    }

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Jameak.CursorPagination.SourceGenerator", "LOCALBUILD")]
    public (global::System.Func<global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>, global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>> applyWhereExpr,
            global::System.Func<global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>, global::System.Linq.IOrderedQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>> applyOrderExpr,
            global::System.Func<global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>, global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>> applyTake)
        BuildPaginationMethods(
        int pageSize,
        bool checkHasNextPage,
        global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection paginationDirection,
        Cursor? afterCursor)
    {
        global::Jameak.CursorPagination.Abstractions.Internal.InternalProcessingHelper.ThrowIfPageSizeInvalid(pageSize, checkHasNextPage);

        var whereExpr = PrivateHelper.GetWhereExpr(afterCursor, paginationDirection);
        global::System.Func<global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>, global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>> whereFunc;
        if(whereExpr != null)
        {
            whereFunc = queryable => global::System.Linq.Queryable.Where(queryable, whereExpr);
        }
        else
        {
            whereFunc = queryable => queryable;
        }

        global::System.Func<global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>, global::System.Linq.IOrderedQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>> orderFunc =
            queryable => PrivateHelper.ApplyOrderBy(queryable, paginationDirection);

        var toTake = pageSize;
        if(checkHasNextPage)
        {
            toTake = PrivateHelper.ComputeToTake(pageSize);
        }

        global::System.Func<global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>, global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>>> takeFunc =
            queryable => global::System.Linq.Queryable.Take(queryable, toTake);

        return (whereFunc, orderFunc, takeFunc);
    }

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Jameak.CursorPagination.SourceGenerator", "LOCALBUILD")]
    public void PostProcessMaterializedResultInPlace(
        global::System.Collections.Generic.List<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>> materializedResult,
        int pageSize,
        bool checkHasNextPage,
        global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection paginationDirection,
        out bool? hasNextPage)
    {
        Jameak.CursorPagination.Abstractions.Internal.InternalProcessingHelper.KeySetPostProcessResultInPlace(
            materializedResult,
            pageSize,
            checkHasNextPage,
            paginationDirection,
            out hasNextPage);
    }

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Jameak.CursorPagination.SourceGenerator", "LOCALBUILD")]
    public Cursor CreateCursor(global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int> data)
    {
        if (data == null)
        {
            throw new global::System.ArgumentNullException(nameof(data));
        }

        return new Cursor(data.Nested.Prop);
    }

#region IKeySetCursorSerializer implementation
    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Jameak.CursorPagination.SourceGenerator", "LOCALBUILD")]
    public Cursor CursorFromString(string cursorString)
    {
        if (cursorString == null)
        {
            throw new global::System.ArgumentNullException(nameof(cursorString));
        }

        try
        {
            var decodedString = global::Jameak.CursorPagination.Abstractions.Internal.InternalProcessingHelper.UrlSafeBase64Decode(cursorString);
            return global::System.Text.Json.JsonSerializer.Deserialize<Cursor>(decodedString, options: PrivateHelper.JsonOptions)
              ?? throw new global::Jameak.CursorPagination.Abstractions.Exceptions.KeySetCursorDeserializationException($"Deserializing '{nameof(cursorString)}' argument produced null Cursor object.");
        }
        catch (global::System.Exception ex)
        {
            throw new global::Jameak.CursorPagination.Abstractions.Exceptions.KeySetCursorDeserializationException($"Failed to decode or deserialize '{nameof(cursorString)}' argument value.", ex);
        }
    }

    /// <inheritdoc />
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Jameak.CursorPagination.SourceGenerator", "LOCALBUILD")]
    public string CursorToString(Cursor cursor)
    {
        if (cursor == null)
        {
            throw new global::System.ArgumentNullException(nameof(cursor));
        }

        try
        {
            var jsonString = global::System.Text.Json.JsonSerializer.Serialize(cursor, options: PrivateHelper.JsonOptions);
            return global::Jameak.CursorPagination.Abstractions.Internal.InternalProcessingHelper.UrlSafeBase64Encode(jsonString);
        }
        catch (global::System.Exception ex)
        {
            throw new global::Jameak.CursorPagination.Abstractions.Exceptions.KeySetCursorDeserializationException($"Failed to serialize '{nameof(cursor)}' argument value.", ex);
        }
    }
#endregion

    /// <summary>
    /// Source generated Cursor holding the data necessary to paginate the
    /// Test.Some.Deep.Namespace.Level1&lt;global::Test.Some.Deep.Namespace.Level2&lt;int&gt;, int&gt;
    /// type using the fields matching this strategy.
    /// </summary>
    [global::System.CodeDom.Compiler.GeneratedCodeAttribute("Jameak.CursorPagination.SourceGenerator", "LOCALBUILD")]
    public sealed record Cursor : global::Jameak.CursorPagination.Abstractions.KeySetPagination.IKeySetCursor
    {
        public int Nested_Prop { get; init; }

        public Cursor(int Nested_Prop)
        {
            this.Nested_Prop = Nested_Prop;
        }
    }
}

[global::System.CodeDom.Compiler.GeneratedCodeAttribute("Jameak.CursorPagination.SourceGenerator", "LOCALBUILD")]
file class PrivateHelper
{
    internal const char CursorElemSeparator = ';';

    internal static int ComputeToTake(int pageSize)
    {
        checked
        {
            return pageSize + 1;
        }
    }

    internal static global::System.Linq.IOrderedQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>> ApplyOrderBy(
        global::System.Linq.IQueryable<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>> queryable,
        global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection paginationDirection)
    {
        switch (paginationDirection)
        {
            case global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection.Forward:
                {
                    var orderedQueryable = global::System.Linq.Queryable.OrderBy(queryable, (obj => obj.Nested.Prop));
                    return orderedQueryable;
                }
            case global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection.Backward:
                {
                    var orderedQueryable = global::System.Linq.Queryable.OrderByDescending(queryable, (obj => obj.Nested.Prop));
                    return orderedQueryable;
                }
            default:
                throw new global::System.ArgumentException("Invalid pagination direction specified.", nameof(paginationDirection));
        }
    }

    internal static global::System.Linq.Expressions.Expression<global::System.Func<global::Test.Some.Deep.Namespace.Level1<global::Test.Some.Deep.Namespace.Level2<int>, int>, bool>>? GetWhereExpr(
        TestStrategy.Cursor? cursor,
        global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection paginationDirection)
    {
        if(cursor == null)
        {
            return null;
        }

        var Nested_PropValue = cursor.Nested_Prop;

        switch (paginationDirection)
        {
            case global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection.Forward:
                return obj =>
                    obj.Nested.Prop! > Nested_PropValue!;
            case global::Jameak.CursorPagination.Abstractions.Enums.PaginationDirection.Backward:
                return obj =>
                    obj.Nested.Prop! < Nested_PropValue!;
            default:
                throw new global::System.ArgumentException("Invalid pagination direction specified.", nameof(paginationDirection));
        }
    }
#region IKeySetCursorSerializer De-/serialization methods
    internal static global::System.Text.Json.JsonSerializerOptions JsonOptions { get; } = InitializeJsonOptions();

    private static global::System.Text.Json.JsonSerializerOptions InitializeJsonOptions()
    {
        var options = new global::System.Text.Json.JsonSerializerOptions
        {
            NumberHandling = System.Text.Json.Serialization.JsonNumberHandling.AllowNamedFloatingPointLiterals,
            PropertyNamingPolicy = new CursorHiddenNamePolicy(),
        };
        
        return options;
    }
#endregion
}

file class CursorHiddenNamePolicy : global::System.Text.Json.JsonNamingPolicy
{
    public override string ConvertName(string name)
    {
        return name switch
        {
            nameof(TestStrategy.Cursor.Nested_Prop) => "0",
            _ => throw new global::System.NotImplementedException($"Unhandled name: {name}"),
        };
    }
}
